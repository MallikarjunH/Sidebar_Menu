//
//  AppDelegate.m
//  emSigner
//
//  Created by Administrator on 7/12/16.
//  Copyright Â© 2016 Emudhra. All rights reserved.
//

#import "AppDelegate.h"
#import "ViewController.h"
#import "iRate.h"
#import "HomeNewDashBoardVC.h"
#import "Reachability.h"

#import "WebserviceManager.h"
#import "HoursConstants.h"
#import "MBProgressHUD.h"
#import "NSObject+Activity.h"
#import "SignatoriesPage.h"
#import <LocalAuthentication/LocalAuthentication.h>
#import <CoreData/CoreData.h>


@interface AppDelegate ()

@end

@implementation AppDelegate
{
    UIViewController *theRootVC;

}

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    
//    NSDateComponents *components = [[NSCalendar currentCalendar] components:NSCalendarUnitDay | NSCalendarUnitMonth | NSCalendarUnitYear fromDate:[NSDate date]];
//    NSInteger month = [components month];
//    NSInteger year = [components year]; //November
//    NSDateFormatter *df = [[NSDateFormatter alloc] init] ;
//    NSString *monthName = [[df monthSymbols] objectAtIndex:(month-1)];


    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSApplicationSupportDirectory, NSUserDomainMask, YES);
    NSString *applicationSupportDirectory = [paths firstObject];
    NSLog(@"applicationSupportDirectory: '%@'", applicationSupportDirectory);

    
            [UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent;
            [NSThread sleepForTimeInterval:2.0];
    
    //Session
    
        CGRect frame = [[UIScreen mainScreen] bounds];
        self.window =[[UIWindow alloc] initWithFrame:frame];
        UIStoryboard *storyBoard = [UIStoryboard storyboardWithName:@"Main" bundle:nil];
    
        NSNumber *number  = [[NSUserDefaults standardUserDefaults] valueForKey:@"isLogin"];
        _isLoggedIn = [number boolValue];
        NSString * CHECK = [[NSUserDefaults standardUserDefaults] valueForKey:@"checkBox"];

    if (_isLoggedIn && [CHECK isEqualToString:@"YES"]) {
        
        theRootVC = [storyBoard instantiateViewControllerWithIdentifier:@"HomeNavController"];
        LAContext *myContext = [[LAContext alloc] init];
        NSError *authError = nil;
        NSString *myLocalizedReasonString = @"Please use secure Biometric for Authentication";

        if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthentication error:&authError]) {
            [myContext evaluatePolicy:LAPolicyDeviceOwnerAuthentication
                      localizedReason:myLocalizedReasonString
                                reply:^(BOOL success, NSError *error) {
                                    if (success) {

                                        
//                                        dispatch_async(dispatch_get_main_queue(), ^{
//                                            //Saving token
//
//                                            [self stopActivity];
//                                        });
                                    } else {
                                        dispatch_async(dispatch_get_main_queue(), ^{
//                                            UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"Authentication Error"
//                                                                                                message:authError.localizedDescription
//                                                                                               delegate:self
//                                                                                      cancelButtonTitle:@"OK"
//                                                                                      otherButtonTitles:nil, nil];
//
//                                            theRootVC  = [storyBoard instantiateViewControllerWithIdentifier:@"ViewController"];
//
//                                            [alertView show];

                                            
                                            UIAlertController * alert = [UIAlertController
                                                                         alertControllerWithTitle:@"Authentication Error"
                                                                         message:authError.localizedDescription
                                                                         preferredStyle:UIAlertControllerStyleAlert];
                                            
                                            //Add Buttons
                                            
                                            UIAlertAction* yesButton = [UIAlertAction
                                                                        actionWithTitle:@"Ok"
                                                                        style:UIAlertActionStyleDefault
                                                                        handler:^(UIAlertAction * action) {
                                                                            //Handle your yes please button action here
                                                                            //Logout
                                                                                                                        theRootVC  = [storyBoard instantiateViewControllerWithIdentifier:@"ViewController"];
                                                                            self.window.rootViewController = theRootVC;
                                                                        }];
                                            
                                            [alert addAction:yesButton];
                                            
                                            [self.window.rootViewController presentViewController:alert animated:YES completion:nil];
                                            // Rather than show a UIAlert here, use the error to determine if you should push to a keypad for PIN entry.
                                        });
                                    }
                                }];
        } else {
            dispatch_async(dispatch_get_main_queue(), ^{
                UIAlertController * alert = [UIAlertController
                                             alertControllerWithTitle:authError.localizedDescription
                                             message:@"Please go to settings page & enable touch id"
                                             preferredStyle:UIAlertControllerStyleAlert];
                
                //Add Buttons
                
                UIAlertAction* yesButton = [UIAlertAction
                                            actionWithTitle:@"Ok"
                                            style:UIAlertActionStyleDefault
                                            handler:^(UIAlertAction * action) {
                                                //Handle your yes please button action here
                                                //Logout
                                                
                                                NSURL *URL = [NSURL URLWithString:@"App-prefs:root=TOUCHID_PASSCODE"];
                                                [[UIApplication sharedApplication] openURL:URL options:@{} completionHandler:nil];                                        }];
                
                [alert addAction:yesButton];
                [self.window.rootViewController presentViewController:alert animated:YES completion:nil];
                //[self presentViewController:alert animated:YES completion:nil];
            });
        }
    
        }
        else if (_isLoggedIn) {
        theRootVC = [storyBoard instantiateViewControllerWithIdentifier:@"HomeNavController"];
        }
        else{
        theRootVC  = [storyBoard instantiateViewControllerWithIdentifier:@"ViewController"];
        }
    self.window.rootViewController = theRootVC;
    return YES;
    
}

#pragma mark -
#pragma mark - AppDelegate Single Instance

+(AppDelegate *)AppDelegateInstance
{
    return (AppDelegate *)[[UIApplication sharedApplication]delegate];
}
- (NSString *)strCheckNull:(NSString *)myStrting
{
    NSString *string = [NSString stringWithFormat:@"%@",myStrting];
    
    if([string isEqual:[NSNull null]] || string==nil || [string isEqualToString:@""] || [string isEqualToString:@"(null)"] || [string isEqualToString:@"<null>"] || [string length]==0)
        return @"";
    else
        return string;
}

- (void)applicationWillResignActive:(UIApplication *)application {
    // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
    // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.
}

- (void)applicationDidEnterBackground:(UIApplication *)application {
    // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.
    // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
    // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.
    
   
}

- (void)applicationDidBecomeActive:(UIApplication *)application {
    // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
    
    [self startActivity:@"Loading..."];
    
    NetworkStatus networkStatus =[[Reachability reachabilityForInternetConnection]currentReachabilityStatus];
    if (networkStatus == NotReachable) {
        UIAlertView *alert = [[UIAlertView alloc]
                              initWithTitle:@"Network Unavailable"
                              message:@"emSigner requires an Internet connection"
                              delegate:nil
                              cancelButtonTitle:@"OK"
                              otherButtonTitles:nil];
        [alert show];
    }
    else
    {
    
    NSURL *myUrl=[NSURL URLWithString:@"https://emsigner.com/downloads/version.json"];
    NSURLRequest *myRequest=[NSURLRequest requestWithURL:myUrl];
    
    NSURLSessionConfiguration *mySessionConfiguration=[NSURLSessionConfiguration defaultSessionConfiguration];
    mySessionConfiguration.requestCachePolicy = NSURLRequestReloadIgnoringCacheData;
    NSURLSession *mySession=[NSURLSession sessionWithConfiguration:mySessionConfiguration delegate:nil delegateQueue:[NSOperationQueue mainQueue]];
    
    NSURLSessionDataTask *myDataTask=[mySession dataTaskWithRequest:myRequest completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error)
        {
                        NSDictionary *myDict=[NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:&error];
                                          
                        NSLog(@"the value is dictionary is %@",myDict);
                                          
                        dispatch_async(dispatch_get_main_queue(), ^{
                            
                        NSDictionary* infoDictionary = [[NSBundle mainBundle] infoDictionary];
                        NSString* currentVersion = infoDictionary[@"CFBundleShortVersionString"];
                        NSString *version = [myDict valueForKey:@"IOSappversion"];
                            
                        float  currentVers = [currentVersion floatValue];
                        float vers = [version floatValue];
                            
                        NSString *forceUpgrade = [myDict valueForKey:@"forceUpgrade"];
                        NSString *recommendUpgrade = [myDict valueForKey:@"recommendUpgrade"];
                            
                        UIWindow* topWindow = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];
                        topWindow.rootViewController = [UIViewController new];
                        topWindow.windowLevel = UIWindowLevelAlert + 1;
                            
                        UIAlertController* alert = [UIAlertController alertControllerWithTitle:@"emSigner" message:[NSString stringWithFormat: @"%@ ", @"New update is available. Please update the application. "]preferredStyle:UIAlertControllerStyleAlert];
                            
                        UIAlertAction* yesButton = [UIAlertAction actionWithTitle:@"Update"
                                                            style:UIAlertActionStyleDefault
                                                            handler:^(UIAlertAction * action)
                                        {
                                            
                                        NSLog(@"you pressed Yes, please button");
                                        NSString *iTunesLink = @"https://itunes.apple.com/us/app/apple-store/id1246670687?mt=8";
                                        [[UIApplication sharedApplication] openURL:[NSURL URLWithString:iTunesLink]];
                                        
                                        }];
                            
                       if ((currentVers < vers) && [forceUpgrade isEqualToString:@"true"]) {
                                          
                           [alert addAction:yesButton];
                           [topWindow makeKeyAndVisible];
                           [topWindow.rootViewController presentViewController:alert animated:YES completion:nil];
                        }
                       else if ((currentVers < vers) && [recommendUpgrade isEqualToString:@"true"])
                       {
                                          
                            UIAlertAction* noButton = [UIAlertAction actionWithTitle:@"No Thanks"
                                                                   style:UIAlertActionStyleDefault
                                                                   handler:^(UIAlertAction * action)
                                                      {
                                                            NSLog(@"ok thanks");
                                                      }];
                                          
                            [alert addAction:yesButton];
                            [alert addAction:noButton];
                                          
                            [topWindow makeKeyAndVisible];
                            [topWindow.rootViewController presentViewController:alert animated:YES completion:nil];
                                          
                        }
                            
                    [self stopActivity];
                });
                                          
    }];
    
    [myDataTask resume];
    [self stopActivity];
        
    }
    [self stopActivity];

}

- (void)applicationWillTerminate:(UIApplication *)application {
    // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
     [self saveContext];
}
#pragma mark -Core Data stack

@synthesize
managedObjectContext = _managedObjectContext;
@synthesize
managedObjectModel = _managedObjectModel;
@synthesize
persistentStoreCoordinator = _persistentStoreCoordinator;

- (NSURL
   *)applicationDocumentsDirectory {
    // The directory the
//    application uses to store the Core Data store file. This code uses a directory
//    named "com.mindstick.CoreDataSample" in the application's documents
//    directory.
    return [[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject];
}

- (NSManagedObjectModel
   *)managedObjectModel {
    // The managed object model for
//    the application. It is a fatal error for the application not to be able to find
//        and load its model.
        if (_managedObjectModel != nil) {
            return _managedObjectModel;
        }
    NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@"Model" withExtension:@"momd"];
    _managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL];
    return _managedObjectModel;
}

- (NSPersistentStoreCoordinator
   *)persistentStoreCoordinator {
    // The persistent store
//    coordinator for the application. This implementation creates and returns a
//        coordinator, having added the store for the application to it.
            if (_persistentStoreCoordinator != nil) {
                return _persistentStoreCoordinator;
            }
    
    // Create the coordinator and store
    
    _persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]];
    NSURL *storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:@"Modeelll.sqlite"];
    NSError *error = nil;
    NSString *failureReason = @"There was an error creating or loading the application's saved data.";
    if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&error]) {
        // Report any error we got.
        NSMutableDictionary *dict = [NSMutableDictionary dictionary];
        dict[NSLocalizedDescriptionKey] = @"Failedto initialize the application's saved data";
        dict[NSLocalizedFailureReasonErrorKey] =
        failureReason;
        dict[NSUnderlyingErrorKey] = error;
        error = [NSError errorWithDomain:@"YOUR_ERROR_DOMAIN" code:9999 userInfo:dict];
        // Replace this
       // with code to handle the error appropriately.
        // abort()
//        causes the application to generate a crash log and terminate. You should not
//        use this function in a shipping application, although it may be useful during
//        development.
        NSLog(@"Unresolvederror %@, %@", error, [error userInfo]);
              abort();
              }
              
              return _persistentStoreCoordinator;
              }
              
              
              - (NSManagedObjectContext
                 *)managedObjectContext {
                  // Returns the managed objectcontext
                 // for the application (which is already bound to the persistent store
                                              // coordinator for the application.)
                      if (_managedObjectContext != nil) {
                          return _managedObjectContext;
                      }
                  
                  NSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator];
                  if (!coordinator) {
                      return nil;
                  }
                  _managedObjectContext = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSMainQueueConcurrencyType];
                  [_managedObjectContext setPersistentStoreCoordinator:coordinator];
                  return _managedObjectContext;
              }
              
#pragma mark -Core Data Saving support
              
              - (void)saveContext {
                  NSManagedObjectContext
                  *managedObjectContext = self.managedObjectContext;
                  if
                      (managedObjectContext != nil) {
                          NSError *error = nil;
                          if
                              ([managedObjectContext hasChanges] &&
                               ![managedObjectContext save:&error]) {
                                  // Replace this
                                 // implementation with code to handle the error appropriately.
                                  // abort()
                                //  causes the application to generate a crash log and terminate. You should not
                                //  use this function in a shipping application, although it may be useful during
                                 // development.
                                  NSLog(@"Unresolvederror %@, %@", error, [error userInfo]);
                                        abort();
                                        }
                                        }
                                        }
                                        
@end
